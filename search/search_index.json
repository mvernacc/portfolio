{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Matt Vernacchia's Engineering Portfolio","text":"<p>I am currently a software engineer at Commonwealth Fusion Systems, where I develop optimization software to aid the design of superconducting magnets and fusion devices for clean energy. </p> <p>I hold a PhD in Aeronautics and Astronautics from MIT, where I developed rocket propulsion systems for small, fast aircraft. These aircraft can fly at 1000 km/hr and are 10x smaller than any air vehicle of comparable speed. Along with my labmates, I fabricated rocket components with metal additive manufacturing, mixed solid rocket propellants, test-fired solid rocket motors, and simulated combustion and heat transfer. I led the development of our lab's solid rocket capabilities from a clean sheet. (more about this project)</p> <p>I love the process of brining difficult technologies from theory to implementation. My experience in analysis, mechanical design, prototyping, and software make me well suited to a fast-paced R&amp;D environment. I built these skills while leading several rocket propulsion projects at MIT (1, 2, 3), integrating a flight simulator for astronauts at SpaceX, and prototyping new human-robot interfaces at JPL, among other experiences.</p> <p>Finding meaning in my work is important to me. I prefer to work with passionate teams on projects with the potential to bend the future of humanity towards better outcomes.</p> <p>resume - publications - hardware projects - software projects</p>"},{"location":"engineering_notes/","title":"Engineering Notes","text":"<ul> <li> <p>2025-05-08: Prefer Butterworth filter over Savitzky-Golay for scientific post-processing</p> </li> <li> <p>2025-11-30: SOS Butterworth filters in Rust</p> </li> </ul>"},{"location":"hardware_projects/","title":"Hardware Projects","text":""},{"location":"hardware_projects/#rocket-propelled-small-fast-aircraft-firefly","title":"Rocket-propelled small fast aircraft (Firefly)","text":"<p>Firefly is a small, fast aircraft which can fly at 1000 km/hr and is 10x smaller than any air vehicle of comparable speed. My PhD research focuses on developing a novel, slow-burn solid rocket propulsion system for such aircraft.</p> <p>read more \u2192</p>"},{"location":"hardware_projects/#hoverjet","title":"Hoverjet","text":"<p>Hoverjet is a jet-powered, vertical-takeoff-and-landing aircraft. I designed the airframe and control mechanisms, and led the fabrication and assembly of the vehicle.</p> <p>read more \u2192</p>"},{"location":"hardware_projects/#additively-manufactured-titanium-rocket-component","title":"Additively manufactured titanium rocket component","text":"<p>This is a component of our research rocket motor which I designed and which is manufactured by Renishaw plc. It illustrates my experience interacting with a manufacturing shop and using GD&amp;T to communicate in drawings.</p> <p>read more \u2192</p>"},{"location":"hardware_projects/#3d-printed-solid-rocket-motor","title":"3D printed solid rocket motor","text":"<p>I worked with my Rocket Team teammates and 3D printing startup Markforged to create and fire the first successful rocket motor printed from plastic. Markforged's printers place glass fibers into the part during printing, which helps the plastic to (temporarily) withstand the intense heat of the rocket exhaust.</p> <p>read more \u2192 </p>"},{"location":"hardware_projects/#strand-burner-for-solid-propellant-testing","title":"Strand burner for solid propellant testing","text":"<p>I designed and built a device to measure the burning rate of solid rocket propellant at elevated pressure. I improved the device though 4 iterations.</p> <p>read more \u2192</p>"},{"location":"hardware_projects/#pyralis-rocket-engine","title":"Pyralis rocket engine","text":"<p>I led the development of a 2 kN thrust, ethanol / nitrous oxide, pressure-fed rocket engine with an aerospike nozzle.</p> <p>read more \u2192</p>"},{"location":"hardware_projects/#high-altitude-balloon","title":"High altitude balloon","text":"As a lab assistant for the Unified Engineering class, I developed a new lab project in which students launch a balloon to the upper stratosphere (70 kft). I designed, built, and flew a prototype balloon with an Arduino-based weather sensing payload. I then wrote an instruction manual for building the system, and coached students though the building and launching process. This photograph was taken by a camera on board one of our baloons."},{"location":"hardware_projects/#rocket-deployed-quadrotor","title":"Rocket-deployed quadrotor","text":"As a sophomore on Rocket Team, I designed and built a quadrotor which folded to fit within a 6 inch diameter rocket. After being launched to 1 mile altitude, the quadrotor would deploy, unfold, and fly autonomously or under remote control. I machined all of the mechanical components and used a Ardupilot Mega for control and communications. I also built and successfully used an emergency parachute system which saved the quadrotor if it lost control."},{"location":"hardware_projects/#assorted-side-projects","title":"Assorted side projects","text":""},{"location":"hardware_projects/#ice-ax","title":"Ice ax","text":"<p>I built my own ice ax for a trip to Mt. Washington. The ax is constructed from steel and poplar, and is reinforced with composites.</p> <p>read more \u2192</p>"},{"location":"hardware_projects/#party-blower","title":"Party blower","text":"A silly device that I designed and printed for my friend's birthday party. It was printed on a Form 2 stereo-lithography printer, which can produce gas-tight parts. *In collaboration with Kelly Mathesius.*"},{"location":"hardware_projects/#loft-bed","title":"Loft bed","text":"<p>I helped my flatmates to design and build loft beds for our apartment. I put some effort into making drawings and instructions, which enabled us to quickly build two identical beds and assemble them without issues. Unlike many loft bed designs, this structure is sufficiently stiff to handle the expected dynamic loads.</p>"},{"location":"publications/","title":"Publications","text":""},{"location":"publications/#rocket-propelled-aircraft","title":"Rocket-Propelled Aircraft","text":""},{"location":"publications/#development-of-low-thrust-solid-rocket-motors-for-small-fast-aircraft-propulsion","title":"Development of low-thrust solid rocket motors for small, fast aircraft propulsion","text":"Matthew Vernacchia, Ph.D. Thesis, Massachusetts Institute of Technology, 2020.  pdf available here"},{"location":"publications/#development-modeling-and-testing-of-a-slow-burning-solid-rocket-propulsion-system","title":"Development, modeling and testing of a slow-burning solid rocket propulsion system","text":"Matthew Vernacchia, MS Thesis, Massachusetts Institute of Technology, 2017. pdf available here"},{"location":"publications/#space-exploration","title":"Space Exploration","text":""},{"location":"publications/#strategies-for-reuse-of-launch-vehicle-first-stages","title":"Strategies for reuse of launch vehicle first stages","text":"Matthew Vernacchia, Kelly Mathesius, International Astronautical Congress, 2018. pdf available here"},{"location":"publications/#enabling-deep-space-exploration-with-an-in-space-propellant-depot-supplied-from-lunar-ice","title":"Enabling deep space exploration with an in-space propellant depot supplied from lunar ice","text":"Sophia Casanova, Jack Henry de Frahan, Vinicius Guimaraes Goecks, ... Matthew Vernacchia, ...,  AIAA SPACE Forum, 2017. DOI: 10.2514/6.2017-5376, pdf available here"},{"location":"publications/#the-lunarport-concept-a-launch-and-supply-station-for-deep-space-missions","title":"The Lunarport concept, a launch and supply station for deep space missions","text":"A comparative study of the two concepts elaborated at the 2017 Caltech Space Challenge.  Jerome Gilleron, Danielle DeLatte, Donal O\u2019Sullivan, P\u00e1draig Lysandrou, Joseph Sparta, Gary Li, ... Matthew Vernacchia, ..., IAA Symposium on the Future of Space Exploration Towards the Moon Village &amp; Beyond, 2017."},{"location":"publications/#robotics","title":"Robotics","text":""},{"location":"publications/#systems-and-methods-for-obtaining-user-command-from-gaze-direction","title":"Systems and methods for obtaining user command from gaze direction","text":"<p>Matthew Vernacchia, US Patent 8 723 798, 2014. link</p>"},{"location":"publications/#gesture-based-robot-control-with-variable-autonomy-from-the-jpl-biosleeve","title":"Gesture-based robot control with variable autonomy from the JPL BioSleeve","text":"Michael T Wolf, Christopher Assad, Matthew Vernacchia, Joshua Fromm, Henna L Jethani, IEEE International Conference on Robotics and Automation, 2013. DOI: 10.1109/ICRA.2013.6630718, pdf available here"},{"location":"publications/#decoding-static-and-dynamic-arm-and-hand-gestures-from-the-jpl-biosleeve","title":"Decoding static and dynamic arm and hand gestures from the JPL BioSleeve","text":"Michael T Wolf, Christopher Assad, Adrian Stoica, Kisung You, Henna L Jethani, Matthew Vernacchia, Joshua Fromm, Yumi Iwashia, 2013. DOI: 10.1109/AERO.2013.6497171"},{"location":"resume/","title":"Resume","text":"<p>pdf resume</p>"},{"location":"software_projects/","title":"Software Projects","text":""},{"location":"software_projects/#material-properties-library","title":"Material properties library","text":"<p>I'm writing a material properties library in python - so far I have a prototype of the core logic. The ultimate goal is to provide for the interchange of information on material properties between CAD software, FEA software, and custom analysis scripts. I spend a lot of time manually transcribing material properties from MatWeb or MMPDS into SolidWorks and my own python scripts. This process is tedious and error prone - I'd like to make it better, and I imagine other engineers would appreciate this too. It would be valuable for a project to have a single (verified) database of material properties, which all of the project's computational tools (CAD, FEA, analysis scripts) reference.</p> <p>example for aeronautical engineering \u2192</p> <p>example for nuclear engineering \u2192</p>"},{"location":"software_projects/#exploring-aircraft-design-tradeoffs-with-geometric-programming","title":"Exploring aircraft design tradeoffs with Geometric Programming","text":"<p>Geometric Programming is an optimization framework for efficiently solving multidiscipliary design optimization problems. As part of my PhD research on small fast aircraft, I am using Geometric Programming to quantify the tradeoffs between range, speed, size, and other aircraft design objectives. This work uses <code>gpkit</code>, a python library for Geometric Programming developed at MIT. This is a work in progress as of spring 2019. In collaboration with Chris Courtin, Beldon Lin and Ned Burnell</p> <p>check it out on github \u2192</p>"},{"location":"software_projects/#rocket-propulsion-library","title":"Rocket propulsion library","text":"<pre><code>&gt;&gt; from proptools import nozzle\n&gt;&gt; p_c = 10e6; p_e = 100e3; gamma = 1.2; m_molar = 20e-3; T_c = 3000.\n&gt;&gt; C_f = nozzle.thrust_coef(p_c, p_e, gamma)\n&gt;&gt; c_star = nozzle.c_star(gamma, m_molar, T_c)\n&gt;&gt; I_sp = C_f * c_star / nozzle.g\n&gt;&gt; print \"The engine's ideal sea level specific impulse is {:.1f} seconds.\".format(I_sp)\nThe engine's ideal sea level specific impulse is 288.7 seconds.\n</code></pre> <p><code>proptools</code> is a python package for preliminary design of rocket propulsion systems. It provides implementations of equations for nozzle flow, turbo-machinery and rocket structures. The project aims to cover most of the commonly used equations in Rocket Propulsion Elements and Modern Engineering for Design of Liquid-Propellant Rocket Engines (Huzel &amp; Huang). It's currently targeted at internal use in my lab, but I am working towards a <code>v1.0</code> that could be used by a broader audience.</p> <p>check it out on readthedocs \u2192</p>"},{"location":"software_projects/#solid-propellant-combustion-simulation","title":"Solid propellant combustion simulation","text":"<p>A simulation of the ignition transient of an ammonium perchlorate composite propellant, implemented in python using <code>cantera</code> and <code>numpy</code>. In collaboration with Sam Judd.</p> <p>read more \u2192</p>"},{"location":"software_projects/#2d-shock-capturing-computation-fluid-dynamics","title":"2D shock-capturing computation fluid dynamics","text":"<p>For a numerical methods class, I programmed a 2D Euler equation (inviscid Navier-Stokes) solver using a finite-difference MacCormack method. I used artificial dissipation to reduce the non-physical oscillations which occur around shocks in finite difference schemes. My software was implemented in Julia.</p> <p>read more \u2192</p>"},{"location":"software_projects/#unscented-kalman-filter-for-3d-attitude-estimation","title":"Unscented Kalman Filter for 3D attitude estimation","text":"<p>I developed a 3D attitude estimator based on the Unscented Kalman Filter (UKF) using a MEMS IMU and a magnetometer. The estimator uses a quaternion representation of attitude, and I explored interesting mathematical issues with applying the UKF algorithm to a quaternion state. I also characterized the sensors' noise, bias, and bias walk.</p> <p>read the report \u2192</p> <p>check it out on github \u2192</p>"},{"location":"software_projects/#aerospike-nozzle-design-gui","title":"Aerospike nozzle design GUI","text":"<p>I implemented a method-of-characteristics aerospike nozzle geometry algorithm in python. I created a GUI which enables users to enter engine parameters and view results. After executing the nozzle design algorithm, the program plots temperature, pressure, and Mach number along the nozzle length, and can export the nozzle geometry in a CAD-compatible format.</p> <p>check it out on github \u2192</p>"},{"location":"software_projects/#crew-dragon-flight-simulator","title":"Crew Dragon flight simulator","text":"<p>During 3 internships with SpaceX, I helped to develop a flight simulator for Crew Dragon. I trained several NASA astronauts to fly the simulator, and helped collect their feedback on the display's UI/UX features and on the vehicle's handling qualities. I then worked with human factors experts, designers, and controls engineers to fix issues discovered in these tests. I mostly worked in C++. I am grateful for the opportunity to have played a small role with the amazing team at SpaceX.</p>"},{"location":"software_projects/#lidar-testing-with-robotic-arm","title":"LiDAR testing with robotic arm","text":"<p>During an internship with SpaceX, I developed software to replicate vehicle flight trajectories using a MILO robotic arm. This enabled the GNC group to perform flight-like tests of their new LiDAR sensor. Thanks to Dr. Andrew Howard for an amazing summer!</p>"},{"location":"engineering_notes/filters_savgol_vs_butter/","title":"Prefer Butterworth filter over Savitzky-Golay for scientific post-processing","text":"<p>2025-05-08</p> <p>For science &amp; engineering data analysis, we often need to smooth noisy time-series measurements. We want to distort the \"real\" signal as little as possible (in both amplitude and delay), and we are filtering during post-processing (not real time).</p> <p>The Savitzky-Golay filter is often touted for providing zero amplitude distortion and zero delay. However, a Butterworth filter applied forward and backward:</p> <ul> <li>also provides zero amplitude distortion and zero delay</li> <li>better removes high-frequency noise</li> <li>stands on firmer theoretical ground from a signal-processing perspective</li> </ul> <p>tl;dr: Stop using the Savitzky-Golay filter for post-processing and use a forward-backward Butterworth filter instead. My recommended solution is:</p> <pre><code>from scipy.signal import sosfiltfilt, butter\nfs = ...  # [Hz] TODO sampling frequency\nfc = ...  # [Hz] TODO filter cutoff frequency\nx_raw = ... # TODO your signal\nORDER = 5  # 5 probably is fine, note that applying the filter forward-backward\n# effectively doubles the filter order.\n\nsos = butter(ORDER, Wn=fc, fs=fs, output=\"sos\")\nx_filtered = sosfiltfilt(sos, x_raw)\n</code></pre> <p>The superior characteristics of the forward-backward Butterworth filter are illustrated in the Bode plot below. If you are new to Bode plots, or simply want more details, read on below.</p> <p></p>"},{"location":"engineering_notes/filters_savgol_vs_butter/#the-task-remove-high-frequency-noise-without-distortion","title":"The task: remove high-frequency noise without distortion","text":"<p>Often, we are trying to measure a relatively slow phenomenon, but our sensors also pick up high-frequency noise.<sup>1</sup> For scientific post-processing, it is imperative to remove the high-frequency noise while:</p> <ul> <li>Accurately preserving the amplitude of the signal.</li> <li>Accurately preserving the signal's position in time, e.g. because we want to determine the times at which some events in the signal occurred.</li> </ul> <p>In signal processing terms, this means we require a filter with:</p> <ul> <li>Gain magnitude of 1 in the pass band</li> <li>Zero phase delay</li> </ul> Zero delay with non-causal filters <p>Zero phase delay is not possible with real-time (causal) filters; but because we are post-processing, we can cheat and \"look ahead in time\" (i.e. use a non-causal filter). This makes our zero delay requirement possible.</p>"},{"location":"engineering_notes/filters_savgol_vs_butter/#meet-the-contenders","title":"Meet the contenders","text":"<p>The Butterworth filter has the flattest possible gain in the pass band (for a filter of a given order with monotonically decreasing gain). That is a strong theoretical recommendation for our scientific post-processing application.</p> <p>The parameters of the filter are a cutoff frequency and an order:</p> <ul> <li>The cutoff frequency should be about 2x the highest frequency you care about in the data, and less than the frequency of known noise sources (e.g. 60 Hz power).</li> <li>Higher orders make the filter better until numerical instabilities appear. An order of 4 or 5 is good for post-processing with 64-bit floating-point numbers (you may need a lower order for numerical stability with 32-bit floats).</li> </ul> <p>The Savitzky\u2013Golay filter can be thought of as fitting a polynomial to successive windows of the data, but in practice it is implemented as a convolution of the signal with a pre-computed kernel (i.e. a FIR filter). Theoretically, the Savitzky\u2013Golay filter does not have much to recommend it.</p> <p>Further, the parameters of the filter are specified as a window length and a polynomial order. It is tricky to relate these to the more useful cutoff frequency; but the window length for a given cutoff frequency can be approximated using equation 11 from this paper, which I implemented in python as the <code>savgol_window_length</code> function.</p>"},{"location":"engineering_notes/filters_savgol_vs_butter/#visualize-filter-performance-with-bode-plots","title":"Visualize filter performance with Bode plots","text":"<p>A Bode plot visualizes the magnitude and phase of a filter's response versus frequency. For the post-processing application, we want a Bode plot that looks like this:</p> Ideal Bode plot for scientific post-processing. <p>Now, we can return to the figure this post started with (it is inlined again below): a Bode plot of the Butterworth (blue) and Savitzky\u2013Golay (tan) filters. For a fair comparison, both filters are set for a -3 dB cutoff at 0.01 times the sampling frequency (vertical black line).</p> The Butterworth filter has a much better looking Bode plot than Savitzky\u2013Golay. <p>Both filters have magnitude of 1 in most of the pass band. At frequencies above the cutoff, the gain of the Butterworth filter drops off rapidly as desired, whereas the behavior of the Savitzky\u2013Golay filter is genuine garbage.</p> <p>Both filters have zero phase over all frequencies, but that's table stakes for non-causal post-processing.</p>"},{"location":"engineering_notes/filters_savgol_vs_butter/#compare-filters-on-noisy-time-series-data","title":"Compare filters on noisy time-series data","text":"<p>The figure below shows each filter's performance on example time series data. The underlying signal is a Lorentzian pulse at t=7 s (black dashed curve), and is contaminated with white noise with a standard deviation of 0.1.</p> The Butterworth forward-backward and Savitzky\u2013Golay both get the time of the peak correct, the Butterworth forward-only filter does not. <p>Both the Butterworth forward-backward (blue) and Savitzky\u2013Golay (tan) filters track the overall shape of the signal well and get the pulse peak at the right time.</p> <p>As a cautionary note, the plot also shows a forward-only Butterworth filter (red). It has phase delay. If you tried to measure the peak time from this filtered signal, you would get the wrong answer (unless you compensate for the phase delay). With <code>scipy.signal</code>, use <code>sosfiltfilt</code>, not <code>sosfilt</code>!</p> <p>Zooming in, we see that the Butterworth forward-backward filter does a better job of rejecting high-frequency noise than Savitzky\u2013Golay. This is consistent with what we saw in the Bode plot.</p> A time scales shorter than the cutoff, the Butterworth-filtered signal is smooth, whereas Savitzky\u2013Golay leaves high-frequency junk in the filtered signal."},{"location":"engineering_notes/filters_savgol_vs_butter/#code","title":"Code","text":"<p>The python scripts that made then figures in this post are available on github.</p>"},{"location":"engineering_notes/filters_savgol_vs_butter/#further-reading","title":"Further reading","text":"<ul> <li><code>scipy.signal.butter</code> docs</li> <li><code>scipy.signal.sosfiltfilt</code> docs</li> <li>S. W. Smith, The Scientist and Engineer's Guide to Digital Signal Processing</li> </ul> <p>Thank you to James Logan for discussing the ideas in this post with me and reviewing the plots. Any errors are my own.</p> <ol> <li> <p>This post focuses on removing noise that is separated from the \"true\" signal in frequency (e.g. electrical noise from 60 Hz power, or high-frequency vibrations of the instrument). Other filtering techniques are better if you want to reject noise on other bases (e.g. outliers).\u00a0\u21a9</p> </li> </ol>"},{"location":"engineering_notes/filters_sos_in_rust/","title":"SOS Butterworth filters in Rust","text":"<p>2025-11-30</p> <p>I recently contributed a second-order sections (SOS) filter implementation to flaw, a digital filtering library for Rust. It targets both embedded platforms (<code>f32</code>, no-<code>std</code>, no-<code>panic</code>) and general-purpose platforms (<code>f64</code>, FMA hardware acceleration).</p> <p>My new <code>flaw::sos</code> module provides:</p> <ul> <li>Implementation of cascaded second-order sections: <code>sos::SisoSosFilter</code><ul> <li>Generic over float type (<code>f32</code>, <code>f64</code>) and number of sections (filter order is up to 2x sections)</li> <li>Designed for efficiency and low numerical error:<ul> <li>Update uses 9 float operations per section</li> <li>Storage is 7 floats per section (2 delays + 5 coefficients)</li> <li>Each stage uses Transposed Direct Form II</li> </ul> </li> <li>FMA and non-FMA implementations, configured by the crate's existing <code>fma</code> feature</li> </ul> </li> <li>Functions to generate SOS Butterworth low-pass filters for a given cutoff frequency: <code>sos::{</code> <code>butter2</code>, <code>butter4</code>, <code>butter6</code> <code>}</code><ul> <li>Provides orders 2, 4, and 6 for <code>f32</code> and <code>f64</code></li> <li>SOS coefficients are interpolated vs cutoff frequency from a lookup table</li> <li>Cutoff frequency region of validity is enforced and tested for each combination of filter order and float type</li> </ul> </li> <li>Python script to auto-generate the SOS Butterworth lookup tables from SciPy: <code>scripts/generate_butter_sos_tables.py</code></li> </ul> <p>Example usage:</p> <pre><code>// Create a low-pass filter with (cutoff frequency) / (sample frequency) = 0.01\n// Butterworth order 4 filter implemented with second-order sections\nlet mut filter = flaw::sos::butter4::&lt;f32&gt;(0.01)?;\n\nloop {\n  let u = 1.0; // get the next raw measurement\n  let y = filter.update(u); // update the filter and get its next output\n}\n</code></pre> <p>Below are my reflections on the project. Thanks to <code>flaw</code>'s maintainer, James Logan, for helping me with this!</p>"},{"location":"engineering_notes/filters_sos_in_rust/#digital-filters-with-f32-are-numerically-challenging","title":"Digital filters with <code>f32</code> are numerically challenging","text":"<p>One target of <code>flaw</code> is embedded platforms where 64-bit float operations are slow or unavailable. Thus, <code>flaw::sos</code> needs to support filters using <code>f32</code>.</p> <p>The resolution of <code>f32</code> is only ~7 decimal digits. A <code>f32</code>-based filter will have rounding errors if it adds together numbers more than a few orders of magnitude apart. Unfortunately, infinite impulse response (IIR) digital filters can have a large range of coefficient magnitudes, particularly at low cutoff ratio (cutoff frequency / sample frequency) for low-pass filters.</p> The large range of filter coefficient magnitudes presents a challenge for 32-bit floats. <p>An SOS form was chosen to improve numerical issues. The same digital filter can be realized in different forms, and these have different robustness to numerical issues. Common forms include:</p> <ul> <li>The four direct forms: Direct I, Direct II, Transposed Direct I, and Transposed Direct II (math reference)<ul> <li>Transposed Direct II is most numerically robust</li> <li>All are susceptible to numerical instabilities, particularly for higher-order filters</li> </ul> </li> <li>State space (math reference)<ul> <li>A modified state space form was used in the existing <code>flaw::SisoIirFilter</code></li> </ul> </li> <li>Cascaded second-order sections (SOS) (math reference)</li> </ul> <p>The SOS form is more numerically robust for filters of order &gt; 2. SOS divides a higher-order filter into a cascade of second-order sections. Within each section, it tends to add values of similar magnitude, reducing rounding errors. In <code>flaw::sos::SisoSosFilter</code>, each section is realized in the numericall-robust Transposed Direct II form.</p> <p>Even with SOS, low-pass Butterworth filters have numerical problems for cutoff ratios that are too low. <code>flaw::sos</code>'s <code>butter</code> methods protect users from creating bad filters by returning <code>Err</code> if <code>cutoff_ratio</code> is below a minimum value. The minimum values are tabulated for each combination of filter order and float precision. Tests ensure that each filter has a DC gain of 1.0 \u00b1 1e-4 at the minimum cutoff ratio (numerical issues manifest as the DC gain departs from 1).</p>"},{"location":"engineering_notes/filters_sos_in_rust/#interpolating-sos-coefficients-for-fast-filter-creation","title":"Interpolating SOS coefficients for fast filter creation","text":"<p>In one case, users need to quickly create a new filter with a different cutoff frequency on an embedded platform. The filter design algorithms are complicated and would not run in the allotted time. Instead, <code>flaw</code> stores lookup tables of the filter coefficients, and interpolates them versus cutoff frequency when creating a new filter. The <code>flaw</code> maintainer (James) developed this approach, and I extended it to SOS filters.</p> The coefficients of a Butterworth low-pass filter vary smoothly with cutoff ratio, and thus are suitable for interpolation. <p>To generate the lookup tables, a Python script calls <code>scipy.signal.butter</code> to calculate the SOS coefficients, and then writes them to a <code>.rs</code> file as a static array. This happens once, before the crate is published. At compile time, the lookup tables are compiled into the Rust binary. If link-time optimization is enabled, the user's binary will only contain the lookup table(s) their code actually uses.</p>"},{"location":"engineering_notes/filters_sos_in_rust/#steady-state-dc-gain-formula","title":"Steady state (DC) gain formula","text":"<p>For a second-order section with z-transform of</p>  H(z) = \\frac{b_0 + b_1 z^{-1} + b_2 z^{-2}}{1 + a_1 z^{-1} + a_2 z^{-2}}  <p>the section's DC gain is</p>  g_{dc} = \\frac{b_0 + b_1 + b_2}{1 + a_1 + a_2}  <p>For a cascaded SOS filter, the overall gain is the product of the section gains.</p>"},{"location":"engineering_notes/filters_sos_in_rust/#uses-gain-correction-after-coefficient-interpolation","title":"Uses: Gain correction after coefficient interpolation","text":"<p>*In <code>SisoSosFilter::new_interpolated</code>, this formula is used to correct the DC gain to 1. A DC gain of 1 is vital: e.g., in a measurement application, if the input is constantly and exactly 1.000 volt, the filter output should converge to 1.000 V, not 0.999 V or 1.001 V.</p> <p>Each set of SOS coefficients in the lookup tables was designed for DC gain of 1, but interpolated coefficients may give a slightly-off-one DC gain. After interpolation, <code>new_interpolated</code> calculates the DC gain of the overall filter, calculates a correction factor</p> <pre><code>let correction = dc_gain.powf(-1.0 / SECTIONS);\n</code></pre> <p>and scales the numerator of each section by <code>correction</code>. This ensures the overall DC gain is 1 to within <code>1e-6</code>.</p> <p>Note that, although the overall DC gain should be 1, the DC gain of each section is often not 1.</p>"},{"location":"engineering_notes/filters_sos_in_rust/#uses-set-the-filter-to-steady-state","title":"Uses: Set the filter to steady state","text":"<p>In <code>SisoSosFiler::set_steady_state</code>, the DC gain formula is used to set the internal state of the filter to its steady-state value for a given input. This is useful in initializing the filter.</p> <p>First, <code>set_steady_state</code> uses each section's steady state gain to calculate what the section output would be in steady state: <code>output = input * ss_gain</code>. With both the input and output known, the section's state can be set using the usual update equations:</p> <pre><code>// Set the internal states based on the steady state input and output of this section\nself.z[s][1] = b2 * input - a2 * output;\nself.z[s][0] = b1 * input - a1 * output + self.z[s][1];\n</code></pre>"},{"location":"engineering_notes/filters_sos_in_rust/#derivation-of-dc-gain","title":"Derivation of DC gain","text":"<p>The filter's DC gain is its z-transform evaluated at z = 1. The DC gain is the final value of filter's the step response. Let H(z) be the z-transform of a second-order section. The z-transform of the section's step response is:</p>  Y(z) = \\frac{1}{1 - z^{-1}} H(z)  <p>The final value theorem for z-transforms states:</p>  \\lim_{n \\rightarrow \\infty} y[n] = \\lim_{z-&gt;1} (z - 1) Y(z)  <p>Applying this to the step response gives:</p>  \\lim_{n \\rightarrow \\infty} y[n] = \\lim_{z \\rightarrow 1} \\frac{z - 1}{1 - z^{-1}} H(z)  <p>The limit of the first term is 1, so we have:</p> <p>$$ \\lim_{n \\rightarrow \\infty} y[n] = H(1) $$ assuming that H(z) is stable so the limit exists. See the list of z-transform properties for more information.</p>"},{"location":"engineering_notes/filters_sos_in_rust/#benchmarking-and-performance-tricks","title":"Benchmarking and performance tricks","text":"<p>I also wanted to make filter updates fast on a general-purpose CPU with <code>f64</code>. Before attempting performance optimization, I set up benchmarking to measure if my changes actually helped. This was easy with criterion. Criterion tracks benchmark statistics and reports if a code change had a statistically significant impact on runtime.</p> <p>The performance tricks I tried and their effects:</p> <ul> <li>Using fused-multiply-add (FMA) instructions: ~40% speedup<ul> <li>Requires setting the <code>target-cpu=x86-64-v3</code> rustc flag to actually get the hardware acceleration.</li> </ul> </li> <li>Unrolling the loop over sections: ~5% speedup</li> <li>Memory-aligning the arrays for coefficient and state storage: no measurable effect<ul> <li>Despite no effect on my i7 CPU, I kept this in, as it may help on embedded platforms with less sophisticated memory controllers</li> </ul> </li> </ul> <p>To support a range of platforms, the FMA implementation is gated by a feature flag. If the <code>fma</code> feature is not set, the non-FMA implementation is used (code snippet below, and on GitHub). The FMA-or-not choice happens at compile time, so there is no performance hit due to added branches.</p> <pre><code>#[cfg(not(feature = \"fma\"))]\n{\n    // Direct Form II Transposed implementation\n    output = b0 * input + self.z[s][0];\n    // Update the filter delays, they will be used the next time this function is called\n    self.z[s][0] = b1 * input - a1 * output + self.z[s][1];\n    self.z[s][1] = b2 * input - a2 * output;\n}\n\n// The FMA implementation is ~40% faster, with target-cpu=x86-64-v3 on a i7-8550U CPU.\n#[cfg(feature = \"fma\")]\n{\n    // Direct Form II Transposed implementation\n    output = b0.mul_add(input, self.z[s][0]);  // b0 * input + self.z[s][0]\n    // Update the filter delays, they will be used the next time this function is called\n    self.z[s][0] = b1.mul_add(input, a1.mul_add(-output, self.z[s][1])); // b1 * input - a1 * output + self.z[s][1]\n    self.z[s][1] = b2.mul_add(input, -a2 * output); // b2 * input - a2 * output\n}\n</code></pre>"},{"location":"engineering_notes/filters_sos_in_rust/#using-ai-in-a-new-domain-coach-not-substitute","title":"Using AI in a new domain: coach, not substitute","text":"<p>Effective and ineffective strategies I've seen for using AI assistants in a new-to-me domain:</p> <ul> <li>Don't: ask AI to write everything for me<ul> <li>Removes my learning, and I don't yet know enough to tell if the results are bad</li> </ul> </li> <li>Do: Design and write the code myself, ask AI for explanations to get unstuck faster<ul> <li>I spend more time learning and less time looking for information</li> </ul> </li> </ul> <p>On this project, I used Codex a lot, but almost exclusively in \"chat\" mode, not \"agent\" mode. It was my first time extensively using generics in Rust and I often ran into compiler errors I didn't yet understand. I found it helpful to give Codex prompts like:</p> <p>At line {X} in src/{Y}.rs, I'm trying to do {A}. I'm getting rustc error {Z}. Explain why this is happening and some options to resolve it.</p> <p>This usually got me un-stuck in a few minutes. I felt I could trust its answers because it was easy to check their correctness with <code>rustc</code>.</p> <p>When learning C++ early in my career, each error like this was a long and frustrating quest -- but no more! The combination of Rust's helpful error messages, Rust's strong compile-time checks, and AI explanations is really helpful for learning.</p> <p>When I was writing the math logic, Copilot eagerly suggested formula completions. Some of these were correct. AI is not a substitute for learning the domain, nor is it a substitute for good tests.</p>"},{"location":"project_pages/firefly/","title":"Rocket-propelled small fast aircraft (Firefly)","text":"<p>Collaborators: Tony Tao, Jon Spirnak, Kelly Mathesius, Chris Courtin, and Prof. R. John Hansman Sponsored by MIT Lincoln Laboratories and BAE Systems, Inc.</p> <p>Firefly is a small, fast aircraft which can fly at 1000 km/hr and is 10x smaller than any air vehicle of comparable speed. My PhD research focuses on developing a novel, slow-burn solid rocket propulsion system for such aircraft.</p> Our \"artist's concept\" of the Firefly aircraft."},{"location":"project_pages/firefly/#motivation","title":"Motivation","text":""},{"location":"project_pages/firefly/#the-small-and-fast-gap","title":"The small and fast gap","text":"<p>Small, uncrewed aerial vehicles (UAVs) are expanding the capabilities of aviation. However, a gap exists in the size and speed capability of aircraft: no aircraft are both small (&lt; 10 kg) and fast (&gt; 100 m/s). This gap is shown in the figure below, which plots the speed vs. size of representative US military aircraft.</p> The speed vs. size design space currently lacks small, fast aircraft. Data from Jane\u2019s Information Group and manufacturer websites."},{"location":"project_pages/firefly/#propulsion-technology-for-small-fast-aircraft","title":"Propulsion technology for small, fast aircraft","text":"<p>A small, fast aircraft requires a propulsion system which is both miniature and high-power - requirements which current UAV propulsion technologies do not meet. To meet this need, we are developing a slow-burn solid rocket motor. Solid rocket motors have a high energy and power density (an advantage over battery-electric systems) and are mechanically simple with no moving parts (an advantage over turbojet engines, especially at small sizes). Thus, solid rocket motors are a promising propulsion technology for small, fast aircraft.</p>"},{"location":"project_pages/firefly/#our-research","title":"Our research","text":"<p>Our research enables development of small, fast aircraft through technology development and design space exploration:</p> <p>Technology development - We are developing a prototype aircraft, and solving the technical challenges encountered along the way. Examples:</p> <ul> <li> <p>Formulating new set of slow-burn solid propellants, measuring their burn rate in a strand burner and rocket motors, and modeling their combustion process.</p> </li> <li> <p>Developing nozzles which can withstand the unique thermal challenges of small, long-endurance rocket motors.</p> </li> <li> <p>Using metal additive manufacturing to produce rocket motor cases.</p> </li> <li> <p>...</p> </li> </ul> <p>Design space exploration - Aircraft design involves complicated trade-offs between range, speed, size, and other metrics. These trade-offs are different for small, fast aircraft than for typical UAVs. We are documenting and quantifying these trade-offs so that future designers can chose the best configuration for their mission and requirements. An optimization technique called Geometric Programming may be a useful tool in this task.</p>"},{"location":"project_pages/firefly/#the-firefly-aircraft-concept","title":"The Firefly aircraft concept","text":"<p>Firefly is concept for a 1-2 kg, Mach 0.8 (1000 km/hr) rocket-propelled aircraft. We are currently doing preliminary design and prototyping of the aircraft, and ground-testing the propulsion system.</p>"},{"location":"project_pages/firefly/#concept-of-operations","title":"Concept of operations","text":"<p>Firefly is meant to launch from a larger (crewed) aircraft at high altitude. It then ignites its rocket motor for several minutes of powered flight at Mach 0.8.</p> A possible concept of operations for a small, fast UAV on an air-launched mission."},{"location":"project_pages/firefly/#aircraft-components-and-configuration","title":"Aircraft components and configuration","text":"<p>The vehicle's configuration integrates a solid rocket motor case into an aircraft fuselage. The vehicle's primary structure is the motor case, which is additively manufactured from a titanium alloy. The fuselage is contoured to reduce drag. The wings and tail feature miniature, high-precision deployment and actuation mechanisms. The major components of the current design revision are shown below.</p> Our candidate design for a small, fast aircraft is built around a slow-burn solid rocket motor."},{"location":"project_pages/firefly/#rocket-motor","title":"Rocket motor","text":"<p>Firefly is propelled by a novel slow-burn solid rocket motor. The initial development of this motor and its propellant was the focus of my Master's thesis.</p> <p>The motor consists of a solid propellant grain, which is surrounded by an ablative liner, and encased in a 2-part motor case. The motor case is additively manufactured from a titanium alloy. Upon ignition, the propellant grain burns from aft to front (an end-burning configuration). This allows for a slow burn, but exposes the interior of the motor to combustion gases. The ablative liner (black in these figures) stands between the combustion gases and the metal motor case to protect the latter from heat.</p> The major components of the Firefly solid rocket motor. To achieve a long burn time, the Firefly motor uses an end-burning propellant grain. This sequence shows the expected regression of the propellant grain (pink) during the burn."},{"location":"project_pages/firefly/#solid-propellant","title":"Solid propellant","text":"<p>The purpose of solid rocket propellants is to generate hot gas at high pressure. This gas is then expanded through a nozzle and ejected from the rocket motor to provide propulsive force. We use a type of propellant called \"ammonium perchlorate composite propellant\" (APCP), which contains a solid oxidizer (ammonium perchlorate) and (optionally) a powdered metal fuel, held together by a rubber-like binder. The binder also serves as a fuel, giving off hydrocarbon vapors during combustion. Despite being a solid propellant, the majority of the combustion energy release occurs in a gas-phase flame above the propellant surface.</p> The composition and flame structure of ammonium perchlorate composite propellant. <p>Typical APCP burns too quickly for the Firefly motor, which requires long endurance and low thrust. Our propellant uses a burn rate suppressant to slow down the combustion process. Part of our research is modeling and testing the effects of this burn rate suppressant.</p>"},{"location":"project_pages/firefly/#motor-case","title":"Motor case","text":"<p>The motor case is produced from Ti-6Al-4V via additive manufacturing. This production technology allows us to contour the case to reduce drag, and to include mounting features for the wing, tails, nozzle and payload.</p> Motor case halves on the build platform after printing. <p>Interestingly, the motor case is a stiffness-limited structure. Packaging constraints forced the motor case to have an elliptical cross section. When pressurized, it will tend to \"squash\" into a circle. If the case deforms to much, it will tear the propellant grain, which could cause the motor to fail. Thus, the case must be sufficiently stiff. We assess this with finite element simulations and hydrostatic tests.</p> Finite element analysis (left) and hydrostatic tests (right) to measure the stiffness of the motor case. <p>If we were to relax some of the packaging constraints, we could use a circular tube motor case, which would be much simpler and cheaper. This would come at the cost of higher drag (and therefore shorter range) and more restricted payload mounting. This trade-off will be revisited in future iterations.</p>"},{"location":"project_pages/firefly/#ablative-liner","title":"Ablative liner","text":"<p>Thermal protection is particularly challenging for small, slow-burn solid rockets because of their end-burning grain configuration and long burn time. The end-burning grain causes the interior of the case to be more exposed to combustion gases. This interior surface must be protected by an ablative liner. It is desirable to make this liner as thin as possible: it adds inert mass to the vehicle and takes up volume which could otherwise be allocated to propellant. Thus, it is important to understand the ablation process, and make a good selection of the ablative material.</p> An ablative liner protects the inside of the motor case from hot combustion gases."},{"location":"project_pages/firefly/#nozzle","title":"Nozzle","text":"<p>The combination of small size and long duration is difficult for nozzle design. Most small nozzle designs rely on heat sinking effects, and would fail after tens of seconds of operation. In contrast many large, long duration nozzles (e.g. on the Shuttle Reusable Solid Rocket Motor) are ablatively cooled. However, the amount of ablation recession does not change with nozzle size, and recession would result in unacceptably large (fractional) changes in the nozzle contour and throat area of a small nozzle. New designs are needed.</p> <p>We are prototyping and testing new nozzle designs. This page describes the design and production of a component used in these tests.</p> <p>Copyright 2019 Matthew Vernacchia and Massachusetts Institute of Technology</p>"},{"location":"project_pages/hoverjet/","title":"Hoverjet","text":"<p>Collabrorators: Jacob Panikulam, Benjamin Kroop, Mason Turner, Isaac Dykeman &amp; others</p> <p>Hoverjet is a jet-powered, vertical-takeoff-and-landing aircraft. I designed the airframe and control mechanisms, and led the fabrication and assembly of the vehicle.</p> <p>This is a work-in-progress as of March 2019.</p> Starting up Hoverjet's jet engine on our 6-axis thrust stand. The four stainless steel vanes in the jet exhaust can be actuated to steer the aircraft. This test measures the forces and torques produced by the jet and vanes."},{"location":"project_pages/hoverjet/#overview","title":"Overview","text":"<p>Hoverjet is an educational project than I am building with few friends (who work in the robotics industry). They wanted to play around with new algorithms for state estimation and control of hovering vehicles. Rather than building a conventional quadrotor, we decided to make a jet-powered vehicle that is controlled via thrust vectoring. This better mimics the dynamics of some interesting systems, like propulsive landing spacecraft. (and having a jet engine to play with made the project more fun).</p> <p>We started designing Hoverjet in the fall of 2018, and met up in Pittsburgh for two weeks over winter break to build the vehicle and begin developing its software. The team in Pittsburgh has done successful static tests, and we are hoping to fly soon!</p> A timelapse of the team assembling Hoverjet's airframe."},{"location":"project_pages/hoverjet/#thrust-vectoring-concept","title":"Thrust vectoring concept","text":"<p>The vehicle controls itself by using vanes in the jet's exhaust stream to change the direction of the thrust vector. The thrust-vectoring concept is illustrated in the figure below, which shows a toy example of translating the vehicle to the right. In order to translate to the right, the vehicle must first tip itself to build horizontal velocity, then tip back to cancel the horizontal velocity and come to rest in a new position. The system is neutrally stable, so a closed-loop control system must constantly make small corrections to keep the vehicle on the desired trajectory.</p> Example of thrust vector control: translation to the right. The jet is illustrated in purple and the vane in black. This 2D example has one vane; the 3D vehicle has four vanes in an 'x' pattern."},{"location":"project_pages/hoverjet/#airframe-design","title":"Airframe design","text":"<p>You can view the CAD model of Hoverjet on Onshape</p> <p>The airframe needs to hold the jet engine, fuel tanks, avionics enclosures, and jet vane units. The aircraft's mass must be balanced around the center of the jet engine, and must remain balanced as fuel is consumed. Because this is a prototype/testing aircraft, the airframe needs to be reconfigurable (e.g. if we decide to add or move sensors). The aircraft needs to be robust to crashes, and it should be easy to replace components if they break or need to be upgraded.</p> This CAD 3-views shows mounting locations of the aircraft's critical components. <p>I addressed these requirements with a modular design. The main structure is four carbon-fiber frame tubes surrounding the engine. All components are held by 3D-printed brackets which clamp on to the frame tubes. Components can be added or relocated by adjusting the bracket locations or printing new brackets. Maintenance is easy: only a single hex key is needed to remove any component (all fasteners are #6 SHCS), and the frequently-accessed avionics bays are on the outside of the vehicle.</p> <p>The vehicle is designed to be crash tolerant: The landing legs are sized to absorb a 5 m/s crash from any direction. The most expensive component, the engine, is \"caged\" by the rest of the structure. The fuel tanks are filled with a open-cell foam, which prevents sloshing and limits severity of a fuel spill if the tanks are ruptured (a technique borrowed from auto racing).</p>"},{"location":"project_pages/hoverjet/#additive-manufacturing","title":"Additive manufacturing","text":"<p>We needed to build and maintain the aircraft in my friend's home machine shop. He does not have CNC cutting machines, so I designed most of the geometrically complicated parts to be made via 3D printing (filament deposition). Below is a time lapse of his Prusa i3 mk3 printing the main frame which holds the jet vanes and frame tubes. The material is a nylon filament filled with chopped carbon fiber (from 3DXTECH). Compared to typical filament plastics (i.e. ABS), it is stronger, stiffer, and maintains it strength up to a higher temperature.</p> Time lapse of printing the main frame. <p>Additive manufacturing is not magic - one still has to pay careful attention to the design-for-manufacturing constraints. However, additive processes have a different set of constraints than traditional cutting and forming processes. Some of the constraints which were important for the Hoverjet parts are:</p> <p>Overhangs - Filament deposition printers cannot print large overhangs, or else the part will sag before the plastic filament cools. When designing the parts for Hoverjet, I considered the orientation in which the part would be printed early in the design process, and shaped the details of the geometry to avoid overhangs in that direction. Some filament printers can allow overhangs by printing a soluble support material under the part, but our printer did not have this capability.</p> <p>Threads and fine holes - Most filament deposition printers do not have sufficient resolution to print threads or fine holes. On Hoverjet, I used heat-set threaded metal inserts to create threads in the printed parts. For holes that needed a close fit around a fastener, I printed the holes undersized, and then drilled them out to the required diameter.</p> <p>Anisotropic strength - Parts made by filament deposition are weaker in the z axis (normal to layers) than in the xy plane (within layers). For loaded parts, the printing orientation was chosen so that the loads would primarily be in the within-layer plane. This sometimes conflicted with the orientation which minimized overhangs, and resolving these conflicts required some judgment.</p> <p>Printing environment - Filament deposition printers are sensitive to the temperature and humidity of the printing environment. Variations in temperature cause the part to cool unevenly, which can distort its geometry or cause layers to peel apart from each other. Many filaments (including nylon) will absorb moisture from humid air, and do not print well when wet. These issues are best managed by printing within an environmentally-controlled build chamber. However, Stratasys Inc. holds a patent on this technology (US 6,722,872), so most hobby-grade printers do not use a build chamber. One can work around this limitation by putting the entire printer within a separately-purchased enclosure. We used this approach, and also put desiccant in the enclosure to keep the humidity down (it's the blue substance in the above video). I put a temperature and humidity gage in the enclosure to monitor the environment.</p> <p>I learned a good deal about additive manufacturing from Prof. John Hart's excellent 2.s998 course. It was fun and instructive to apply what I had learned to this project.</p>"},{"location":"project_pages/hoverjet/#infrared-radiation-shield","title":"Infrared radiation shield","text":"<p>One interesting feature of the airframe is the IR radiation shield. This reduces the radiative heat transfer from the jet nozzle to the surrounding structural components. These components are composite, and will weaken if they get above 350 K. The nozzle is only a few cm from these components, and will reach 1000 K, hot enough to emit a significant amount of thermal radiation (radiative power \\sim T^4). To reduce radiative heating of the structure, I surrounded the nozzle with a two-layer radiation shield made of aluminum. Infrared radiation from the nozzle must be absorbed and re-radiated by each layer before reaching the structure. The layers are separated by fiberglass cloth to prevent contact and thermal conduction between the layers. This design is vaguely similar to the multilayer insulation used on spacecraft.</p> <p>The shield works - during static tests we have run the engine at full throttle for several minutes without any damage to the surrounding structure.</p> A view looking up into hoverjet from below shows the radiation shield surrounding the engine nozzle."},{"location":"project_pages/hoverjet/#design-ideation-process","title":"Design ideation process","text":"<p>We started by discussing the goals and requirements as a team. Crash tolerance and modularity/maintainability were the key concerns. I then though about manufacturing constraints - how much money were we willing to spend, what tools were available in my friend's shop, how much of the vehicle could I make on campus and bring with me?</p> <p>After establishing this context, I made a few design sketches (see below) and discussed them with the team. We selected the dual-tank configuration.</p> Preliminary sketches of two configuration options. <p>I then asked the team to select or specify dimensions for the major components. I made a rough-cut CAD assembly to make sure all the major components fit. After reviewing this with the team, I preceded to the detailed mechanical design.</p> Rough CAD model to check fit of major components. <p>Throughout the entire process I kept a mass budget of the vehicle, which I refined as the design matured. The final design came in slightly under the initial mass prediction (9 kg vs 10 kg).</p>"},{"location":"project_pages/hoverjet/#jet-vane-control-mechanism","title":"Jet vane control mechanism","text":"<p>Hoverjet has four Jet Vane Units which provide control over the vehicle. The vanes are mounted in the exhaust of the jet in an 'x' pattern. Rotating the vanes deflects or swirls the exhaust jet, which applies forces and torques to the aircraft. By actuating different combinations of the vanes, we can produce all three torque components (roll, pitch, and yaw).</p> <p>Each Jet Vane Unit consists of a vane, a servo which actuates the vane, a gear train connecting the servo to the vane, and a body and housing. The bodies were rather complicated, so I outsourced the machining to Protolabs (a rapid-prototyping shop). The other components I machined on-campus or 3D printed. In order to resist the exhaust temperatures, the jet vanes are made from AISI 316 stainless steel. The vanes have held up well to several minutes of operation at full throttle (although the heated portions have developed a beautiful rainbow oxide pattern). The figure below shows the four assembled Jet Vane Units ready to be inspected, tested and installed on the aircraft.</p> Jet Vane Units. <p>I sized the vanes using a rough model of the aerodynamic forces on a flat plat. Compensating for a misalignment of the center of mass turned out to be the driving case for the vane size. My vane sizing worksheet is available on github as an Ipython notebook. (TODO: some of my notes are still on paper and have not been typed into the ipython notebook :( )</p> <p>I determined required servo speed using a linearized model of the aircraft dynamics. Typically, the required actuator bandwidth would be set by the natural frequencies of a system, but hoverjet does not have any natural frequency (the linear dynamics are just 4 poles at the origin). Instead, the servo speed is set by the required position control resolution. If the vane can be moved faster, we can drive smaller position oscillations. My servo speed worksheet is available on github as an Ipython notebook.</p>"},{"location":"project_pages/hoverjet/#system-identification","title":"System identification","text":"<p>Before flying Hoverjet, we need to calibrate the response of the vehicle dynamics to control inputs (System Identification). Specifically, we want to know how the forces and torques applied to the vehicle vary with vane angles and engine throttle setting. A dynamics model derived from this information is used by Hoverjet's Model-Predictive Controller.</p> <p>To make these measurements, we made a thrust stand capable of measuring all 3 forces and 3 torques on the vehicle. This could be done by a 6-axis load cell, but those cost many thousands of dollars. Instead, I built a thrust stand which measured the forces an torques using a kinematically exact arrangement of 6 one-axis load cells. These load cells cost $10 each, and the remaining hardware and aluminum extrusion for the stand totaled $600. Kinematically exact constraint is a nifty design principle;  a good introduction can be found in Ch 2.6 of Dr. Layton Hale's PhD thesis.</p> Left: Hoverjet mounted horizontally on the Thrust Stand. Right: thrust stand uses a kinematically exact arrangement of 6 load cells to measure 3 forces and 3 torques produced by the jet and vanes. <p>We discovered an important bug during hardware-in-the-loop testing on the Thrust Stand: the magnetic field from the jet engine's fuel pump motor interfered with the navigation system's magnetic compass. This bug would have resulted in a crash had if we had not caught it before flight testing.</p>"},{"location":"project_pages/ice_ax/","title":"Ice ax","text":"<p>I built my own ice ax for a trip to Mt. Washington. The ax is constructed from steel and poplar, and is reinforced with composites. I spent a few hours designing and building the ax, with the goal of practicing metalworking and composite layups.</p> <p></p>"},{"location":"project_pages/ice_ax/#design","title":"Design","text":"<p>The ice ax has a 14 cm pick and a 70 cm handle. I sized the handle length to match the distance between my palm and ankle, the recommended size for mountaineering axes. The pick and the shaft form a 70 degree angle, which is typical for mountaineering axes (technical climbing tools use a steeper angle of 50 to 60 degrees).</p> <p>The head and spike are made from steel. Typical ax materials are steel, titanium and aluminum - I chose steel because titanium was too expensive, and aluminum would be too soft. I have no idea what alloy the steel is, it was a piece of scrap I found lying around in the shop.</p> <p>The head and spike are attached to the shaft by slotted joints held in place by 6.4 mm (0.25 inch) steel pins. The joints are then tension-wrapped with unidirectional carbon fiber tow to prevent the wood slot from splitting. Finally, the joints are wrapped in fiberglass tape to provide additional strength and to protect the carbon fiber from abrasion. (The fiberglass abrasion protection is inspired by a few firefighting COPVs I've seen).</p> Sketches of the ax from my design notebook."},{"location":"project_pages/ice_ax/#fabrication","title":"Fabrication","text":"<p>I cut the outline of the head from steel stock on a bandsaw. I then cut teeth into the pick with an angle grinder, and sharpened the tip and adze on a bench grinder. I cut the slots and pin holes into the wood, and used an arbor press to insert the pins.</p> <p>Next, I did the carbon fiber wrap. I then overwrapped with fiberglass tape, and wrapped the handle with fiberglass cloth. I used using West Systems 105/209 epoxy for the layups. Next, I vacuum-bagged the layup to remove excess epoxy and press the tape wrap into the head-shaft joint.</p> The carbon fiber tension wrap around the head joint. The layup cures while compressed in a vacuum bag."},{"location":"project_pages/ice_ax/#results","title":"Results","text":"<p>The design and fabrication took 5 hours. The finished tool weights 780 g, which is on the heavy side of the typical range. I tested the tool (in a non-safety critical role) during a hike up Mt. Washington, and it performed well.</p> At the summit of Mt. Washington. I'm second from the left."},{"location":"project_pages/nozzle_adapter/","title":"Additively manufactured titanium rocket component","text":"<p>Collaborators: Kelly Mathesius (MIT), Carl Hamann (Renishaw plc.)</p> <p>This is a component of our research rocket motor which I designed and which is manufactured by Renishaw plc. It illustrates my experience interacting with a manufacturing shop and using GD&amp;T to communicate in drawings.</p> Engineering drawing of the component."},{"location":"project_pages/nozzle_adapter/#context-and-interfaces","title":"Context and interfaces","text":"<p>This part enables us to test miniature rocket nozzles on our research rocket motor. The rocket propelled aircraft we are developing requires a nozzle with insulation that can withstand exposure to hot combustion gases for several minutes - a challenging design that must be prototyped and tested. This adapter mimics the mechanical interface on the aft end of the aircraft's motor case, allowing us to mount the flight-like nozzle onto our research rocket motor. Thus, we can flow combustion gases through the nozzle to test its performance.</p> The nozzle adapter (purple) in its assembly context."},{"location":"project_pages/nozzle_adapter/#material-selection","title":"Material selection","text":"<p>The adapter is made from Ti-6Al-4V ELI, a titanium alloy. It is produced from metal powder via powder bed fusion additive manufacturing. The material and manufacturing process are the same as the motor case which the adapter is meant to simulate. This is important so that the adapter is an accurate check for issues with finish, strength at elevated temperatures, thermal expansion, etc.</p>"},{"location":"project_pages/nozzle_adapter/#analysis","title":"Analysis","text":"<p>After designing the part, I performed finite element analysis (FEA) to check the expected stresses in the part. A separate analysis of heat transfer through the ablative liner predicted that the maximum temperature of this part would be 700 K. In the FEA, I used material properties for Ti-6Al-4V adjusted to this temperature (I looked these up in MMPDS).</p> <p>I used the built-in FEA package in SolidWorks to perform the analysis. To reduce the computational cost, I took advantage of the 4-fold symmetry of the part and only simulated one quarter with periodic boundary conditions.</p> <p>At the design pressure of 1.9 MPa, the factor of safety (yield tensile stress / max von Mises stress) was greater than our required value of 1.5.</p>"},{"location":"project_pages/nozzle_adapter/#outsourced-manufacturing","title":"Outsourced manufacturing","text":"<p>The on-campus machine shop does not have equipment for metal additive manufacturing or machining titanium. We outsourced this part to Renishaw plc., which manufactures metal AM systems and offers AM + machining services.</p> <p>I began the discussion with Renishaw by sending a preliminary model of the part and a description of the context in which it would be used. Carl Hamann from Renishaw discussed the design-for-manufacturing concerns. We decided the best way to to manufacture the part was to print a near net shape, and then machine precision features on a CNC mill. We also identified a few modifications which made the design easier to produce on their machines and tools. This process was smooth, as we have previously ordered several parts from Renishaw and developed a good relationship.</p> <p>Then, I prepared an engineering drawing of the part (see figure at top of article). I also prepared two 3D models: one of the \"as printed\" near net shape, and one of the final geometry after printing. Mr. Hamann used these files to program the AM system and mill.</p> The parts being sintered in Renishaw's additive manufacturing system."},{"location":"project_pages/nozzle_adapter/#fit-check-and-next-steps","title":"Fit check and next steps","text":"<p>Renishaw first manufactured one instance of the part and sent it to us for a fit check. The nozzle adapter's \"bayonet fitting\" fit well onto the nozzle (see figure below).</p> <p>However, the o-ring grooves were too shallow, and so the adapter could not be installed into the motor without cutting the o-rings. The cause of the error has been identified, and we expect to receive and fit test a new part in the coming week (as of 2019-04-01).</p> The first parts assembled for a fit check. <p>Once the part passes the fit check, we will perform a hydrostatic pressure test to check for leaks and verify that the assembly does not yield under the (margined) pressure load. We will then put the part on our rocket motor and fire it!</p>"},{"location":"project_pages/pyralis/","title":"Pyralis rocket engine","text":"<p>Collaborators: James Logan, Connie Liu, Andre Kessler, Sam Judd, Jeff Mockleman &amp; others</p> <p>I led the development of a 2 kN thrust, ethanol / nitrous oxide, pressure-fed rocket engine with an aerospike nozzle.</p> <p></p> <p>Pyralis is a liquid-bipropellant rocket engine created by the MIT Rocket Team. I lead the development of Pyralis as Team President (2013-14) and Propulsion Lead (2014-15). The engine burns ethanol and nitrous oxide, and produces 2 kN of thrust at a chamber pressure of 8 MPa. The nozzle is an altitude-compensating aerospike made from machinable alumina ceramic. The combustion chamber is uncooled, and is made from 316 stainless steel insulated with zirconia ceramic.</p>"},{"location":"project_pages/pyralis/#design","title":"Design","text":"<p>Our rocket design process started by defining our goals and requirements. We wanted to use the engine to launch a rocket to 10,000 ft in the Intercollegiate Rocket Engineering Competition (IREC), a goal we ultimately did not achieve. We also wanted to learn and inspire our teammates with the project - Rocket Team needs a compelling and exciting project to keep its members coming.</p> <p>One of our first design tasks was to select the propellants. The need to operate in the Utah desert for IREC motivated the use of storable (not cryogenic) propellants. We selected ethanol and nitrous oxide because it is a low-toxicity and available combination of storable propellants.</p> <p>We selected the aerospike nozzle because of our educational and inspirational goals. The aerospike is an advanced nozzle technology that offers improved specific impulse compared to a conventional de Laval nozzle. In retrospect, I think choosing the aerospike was overly ambitious, but it certainly did get people excited about rocket team!</p> Components of the Pyralis engine <p>We then developed the hardware via an iterative process. We first build a cold gas testbed to practice working with fluid systems and verify our nozzle design algorithm. We then designed, built and tested a prototype engine, which went through two major design iterations between March 2014 and January 2015.</p> <p>The following sections describe the design process for the injector and combustion chamber.</p>"},{"location":"project_pages/pyralis/#injector","title":"Injector","text":"<p>The injector is uses a triple-impinging jet pattern. The injector is assembled from 3 plates of 316 steel - the bottom plate contains the injector orifice holes, the middle plate forms 2 annular channels to distribute fuel and oxidizer to the orifices, and the top plate closes the channels and provides attachment points for the thrust frame. Copper gaskets seal between the plates. In addition to distributing propellant, the injector has pass-thoughs for a pressure tap, temperature sensor and the ignition system.</p> Fuel (orange) and oxidizer (green) flow though the triplet injector. Note this figure shows an o-ring seal; the seal design was later changed to use copper gaskets. <p>The injector was originally designed by Jeff Mockleman. His design used swirl-flow orifices which achieved very good mixing. However, the swirl orifices were difficult to manufacture accurately, so the tolerance on the orifice area was poor. Water flow tests showed that the area tolerance caused our pressure drop and mass flow rate to be unacceptably far from their design values. To remedy this problem, Connie Liu and I redesigned the injector to use drilled hole orifices in a triplet configuration. The drilled holes could be manufactured to much tighter tolerance that the previous design. Further water flow tests validated the new design.</p> A water flow test of the re-designed injector. Video editing by Andre Kessler. <p>I also performed a thermal analysis on the injector. I used Nusselt number techniques to estimate the heat transfer coefficients between the injector and the combustion chamber gases, and between the injector and the liquid propellant flows. These heat transfer coefficients provided boundary conditions for a finite element heat transfer simulation (SolidWorks Simulation). The results of the steady-state thermal analysis indicate a maximum temperature of 1400 K. This is slightly above the operating limit (1170 K) of the injector's steel alloy, indicating that the injector is not suitable for steady-state operation. However, during the short burn time (15 s), the engine does not reach steady state. A more detailed transient thermal analysis should have been performed, but we did not have the computational resources at the time.</p> Temperature distribution in a cross section of the injector in steady-state operation."},{"location":"project_pages/pyralis/#combustion-chamber-and-nozzle","title":"Combustion chamber and nozzle","text":"<p>The Pyralis engine\u2019s combustion chamber and convergent nozzle region are contained by a cylindrical structural wall made from 316 steel. Chemical equilibrium analysis predicts a combustion temperature of 1900 K, well above the maximum operating temperature of 316. Therefore walls of the combustion chamber must be thermally protected. We chose an insulating thermal liner, which offers greater simplicity than regenerative cooling, and better re-usability than ablative cooling.</p> A view of the Pyralis engine showing the ceramic nozzle. <p>The thermal liner consists of a cast zirconia ceramic, which has high temperature tolerance and low thermal conductivity. The steel wall is protected partially by the thermal resistance of the liner, and partly by its heat capacity. This thermal design cannot withstand steady-state operation, but our mission requires a relatively short (15 s) burn time.</p> A CAD rendering cross section showing the nozzle support structure. <p>The nozzle's spike is made from machinable alumina ceramic. Machinable alumina was selected because of its higher strength and better fabrication tolerances (compared to the cast zirconia used in the liner). James Logan designed a clever web structure to support the nozzle spike within the combustion chamber. I designed the spike's contour using a method of characteristics algorithm.</p> Transient thermal analysis of the combustion chamber wall."},{"location":"project_pages/pyralis/#testing","title":"Testing","text":"Rocket team members pose with the engine and test stand before our first static firing. Our faculty advisor, Prof. Lozano stands to the left. James Logan and Ryan Webb wear fire-resistant personal protective equipment, as they will fill the propellant tanks."},{"location":"project_pages/pyralis/#test-facilities","title":"Test facilities","text":"<p>We tested the engine in a blast chamber in MIT's Gas Turbine Lab. The test stand structure was built from steel uni-strut and reinforced with steel cable. Plywood was used to create mounting panels for valves and tanks; the wood was treated with a flame retardant to reduce the risk of unwanted fire. The engine's exhaust was cooled by a water sprayer, and then routed through a J-shaped steel duct to a vent fan in the room's ceiling.</p>"},{"location":"project_pages/pyralis/#safety-and-procedures","title":"Safety and procedures","text":"<p>Together with other team members, I developed safety plans and procedures for the static firing. We researched toxicity, fire and explosion hazards, reviewing papers about test facilities for similar engines operated by JAXA and NASA. We then revised our plans through discussions with the Environment, Health and Safety department (EHS) and experienced lab technicians. We created impact/probability charts to document the hazards present in the test, and selected mitigation strategies. Finally, we wrote and practiced a detailed checklist for the test. The checklist covered the nominal procedure, and also contained various abort procedures to return the system to a safe state after a failure.</p>"},{"location":"project_pages/pyralis/#first-static-fire-hard-start","title":"First static fire - hard start","text":"<p>We performed our first static firing attempt in May 2014. This test failed due to a hard start, which destroyed parts of the combustion chamber and some plumbing. On this version of the engine, the ignition system was a simple spark plug sticking into the combustion chamber, and our propellant flow was controlled by non-throttleable solenoid valves, which open to full flow in 30 ms. Writing now, with several more years of experience and grad classes in combustion under my belt, it seems obvious that this poor design would hard-start. But sometimes I end up learning things the hard way.</p> Video stills from the hard start during the May 2014 static fire. At t=0, the spark plug and solenoid valves were energized. At t=+66 ms (top frame), the valve opening and pipe flow transients have passed, and the full propellant flow is passing though the injector. However, the propellant has not ignited, and a strong jet of unburnt propellant mist flows out of the nozzle.     At t=+99 ms (bottom frame), ignition occurs. Because the fuel and oxidizer are still liquids in the combustion chamber, their density is high and large mass of propellant is in the combustion chamber. When this mixture ignites, a huge amount of energy is released (~1 MJ). The chamber pressure spikes. The incompressible liquid propellants transmit the pressure shock to the engine and plumbing structure. The hose supplying oxidizer to the engine explodes. Glowing wires from the hose\u2019s metal braid can be seen flying away. The pressure exerts a strong downward force on the spike, which structurally fails and is ejected downwards out of the engine. <p>In response, we spent the summer and fall of 2014 redesigning and rebuilding the engine. We developed a hydrogen / air pilot torch to replace the spark igniter and redesigned the injector. We also built our own servo-controlled throttle valves so we could ramp up the propellant flow more gradually.</p>"},{"location":"project_pages/pyralis/#second-static-fire-smooth-ignition-but-flame-out","title":"Second static fire - smooth ignition, but flame-out","text":"<p>We tested the new engine in December 2014. Our hard-start remedies were successful - the engine started smoothly! However, it flamed-out after a few seconds of operation. We believe that the L^* of the combustion chamber (about 0.7 m) was too short to maintain stable combustion of the propellants.</p> A static firing of the Pyralis engine. We fired our pilot torch (air and hydrogen) for 20 seconds before flowing our main propellants. The engine ignites at about 22 seconds according to the timestamp in the video. Video editing by Connie Liu."},{"location":"project_pages/pyralis/#conclusion","title":"Conclusion","text":"<p>Unfortunately, we had to cancel the project before we could achieve a full-duration static fire. In a subsequent test in January 2015, we accidentally damaged the blast chamber's ventilation system. Previous maintenance had replaced the room's vent fan with a non-explosion-proof fan. When one of our tests vented unburnt propellant vapor though the fan, a spark from the motor ignited the vapor, and the resulting explosion destroyed the fan. Connie Liu and I conducted a thorough investigation into the incident. Among other analyses, I used the Weibull formula to predict the overpressure from a propellant vapor explosion, and found that this overpressure matched the observed structural damage.</p> <p>Because the building we were testing in was scheduled for renovations in a few months, MIT decided not to repair the vent. We had lost our test site, and only had a few months remaining before our project deadline (we were planning to fly the engine at the Intercollegiate Rocket Engineering Competition (IREC) in June 2015). Therefore, we decided to cancel further development of Pyralis, and switched to a commercial-of-the-shelf solid rocket motor for IREC 2015. Difficult as it was to make, this ended up being the right call. With the extra manpower freed up from the propulsion system, the team built an excellent rocket and recovery system, which won the basic category of IREC.</p> <p>Although it was disappointing to cut the project short, we learned much from what we were able to accomplish. I loved playing mentor to my younger teammates, and using the project to inspire their excitement about engineering and propulsion. Almost everyone involved has gone on to apply what they learned on Pyralis to other propulsion projects at MIT, SpaceX, Firefly, NASA, ULA, and Northrop Grumman.</p> MIT Rocket team's 2015 rocket launches in the IREC competition. Unfortunately, we did not finish the Pyralis engine in time, and flew this rocket on a off-the-shelf solid rocket motor instead. Despite this change, the team built an excellent rocket and won first place in the competition."},{"location":"project_pages/strand_burner/","title":"Strand burner for solid propellant testing","text":"<p>Collaborator: Tony Tao</p> <p>As part of my Master's research, I designed and built a device to measure the burning rate of solid rocket propellant at elevated pressure. I improved the device though 4 iterations.</p> A strand burner test played back at 4x speed."},{"location":"project_pages/strand_burner/#motivation","title":"Motivation","text":"<p>One of the key steps in the development of a new solid rocket propellant is to characterize the burn rate as a function of pressure. The burn rate (r) versus pressure (p) relationship is typically modeled by Vielle's Law:</p> r = a p^n <p>where a and n are parameters which must be determined experimentally.</p> <p>These experiments are performed with a strand burner, a device which burns small samples (\u201cstrands\u201d) of propellant at a controlled pressure and measures their burn rate.</p>"},{"location":"project_pages/strand_burner/#final-design","title":"Final design","text":"<p>The design goals for the strand burner were to allow rapid exchange of propellant samples, laser ignition of the propellant, and optical observation of the flame front. The overall design of the apparatus is shown below:</p> Subsystems of the strand burner apparatus. <p>The strand burner has four subsystems:</p> <ol> <li>The sample holder holds the propellant sample and the laser igniter. The sample is contained in a quartz glass tube, which allows for optical observation of the flame front. The laser igniter is a 6 W, 455 nm diode laser which ignites the propellant sample by heating a small patch on its front face.</li> <li>The plenum collects combustion gases from the burning propellant sample. Gas is vented from the plenum through the backpressure regulator. A large plenum smooths out variations in pressure, and allows solid particles to settle out before reaching the backpressure regulator.</li> <li>The backpressure regulator maintains the desired pressure in the plenum by venting gas if the pressure exceeds the set-point. The backpressure regulator is sensitive to clogging, so it is placed on the far side of the plenum (to allow solid particles to settle out of the flow) and is protected by a filter.</li> <li>A pressure sensor measures the pressure in the plenum.</li> </ol> <p>A camera is set up to record the progress of the flame front through the sample. An analog to digital converter and computer record the plenum pressure and the laser current.</p> <p>The sample holder is the most mechanically complex part of the strand burner. Its design is shown in the figure below. The purpose of the sample holder is to hold the propellant sample in alignment with the laser, and to create a sealed, pressurized path from the propellant sample to the plenum.</p> Details of the strand burner sample holder. Top: the sample holder opens to change samples and clean the laser window. Middle: a cross section showing the laser beam path and components of the sample holder. Bottom: view of the sample holder during a propellant test. The dashed rectangle on the middle subfigure outlines the image field of view."},{"location":"project_pages/strand_burner/#operations-and-safety","title":"Operations and safety","text":"<p>We operate the strand burner in a blast chamber facility at MIT. The blast chamber has thick concrete walls which protect us if the propellant sample explodes during the test. After loading the propellant sample into the strand burner, we run the test remotely from a control and data logging station located outside of the blast chamber. We use checklists to ensure that we operate the apparatus correctly and safely.</p> <p>Laser safety is another operational concern. It is important to not inadvertently turn on the laser while people are working on the apparatus, as the laser could blind someone. We employ magnetic interlocks on the blast chamber door prevent the laser from being energized unless the door is closed, after everyone has exited the chamber.</p>"},{"location":"project_pages/strand_burner/#design-iterations","title":"Design iterations","text":"<p>The design presented above is the fourth version of the strand burner. Over these iterations I evolved the design of the strand burner to make it more robust and useable. I also learned more about mechanical design during the year over which these revisions were made.</p>"},{"location":"project_pages/strand_burner/#version-1","title":"Version 1","text":"<p>In the first version, the propellant sample was mounted inside the chamber, and the chamber was made from acrylic to permit viewing. However, smoke from the exhaust filled the chamber, blocking the view of the burning sample. Also, the acrylic blistered and discolored after several firings, limiting the useful life of the device.</p> The version 1 strand burner: CAD model (left), assembled pressure vessel (right)."},{"location":"project_pages/strand_burner/#version-2","title":"Version 2","text":"<p>Version 2 of the strand burner solved these issues by mounting the sample on the outside of the chamber. This required the sample tube be loaded with internal pressure. Despite the poor tensile properties of quartz glass, I was able to find a sufficiently thick-walled tube to meet this load. However, v2 revealed a new set of flaws: its backpressure regulator became corroded and clogged with soot, and as the regulator clogged the internal pressure varied. Also, reloading a propellant sample in v2 required removing and replacing several #6 screws, and installing a new pyrotechnic igniter. We wear fire-resistant gloves when handling propellant, so these dexterous operations were slow and frustrating.</p>"},{"location":"project_pages/strand_burner/#version-3","title":"Version 3","text":"<p>Version 3 solved these problems: a large chamber reduces pressure variations, a stainless steel backpressure regulator resists corrosion, and filters prevent soot from reaching the regulator. The propellant sample is installed and removed with a toggle clamp, and the laser igniter is reusable. However, on v3 the laser was mounted across the plenum from the propellant sample. The angular alignment of the laser had to be very precise (&lt; 0.5 deg) to keep the laser spot on the propellant sample. Bumping the apparatus could knock the laser out of alignment.</p> The version 3 strand burner design drawing. Not that the Laser Mount is on the opposite end of the Chamber from the Sample Holder. The version 3 strand burner, set up in the blast chamber facility."},{"location":"project_pages/strand_burner/#version-4","title":"Version 4","text":"<p>On version 4, I moved the laser on to the sample holder (see figure above in the Final design section). Mounting the laser close to the propellant sample makes the system much less sensitive to the alignment of the laser. The v4 strand burner is robust and easy to use.</p>"}]}